Двухпроцессорная версия программы. Задачи распределяются поочередно. Для этого заведена специальная переменная в классе балансировщика.
Вывод преобразован для понятности работы с двумя процессорами. Для того, чтобы продемонстрировать непустоту очередей, очереди просто выводятся на каждом шаге работы.

Если, например, предыдущее задание взял первый процессор, а второй сейчас занят, задание идет в очередь второго процессора и за взятое не считается. Оно помечается как задание, положенное в очередь. Из очереди оно идет в календарь. Из каледаря на выполнение. Если задание на i-м процессоре попадает в очередь, этот же процессор потом должен будет его завершить. Поочередно распределяются новые запросы, а не старые. Очередь у каждого процессора своя. Аналогия - два физических буфера, находящихся непосредственно на серверах, а не на балансировщике.
 
Изначально было так: если процессор занят, задание попадает в очередь. А из очереди оно попадает в календарь как только процессор закончит выполнение задания. При этом генерация следующего события планируется после обработки EV_REQ независимо от занятости процессора, от очереди и прочего. В результате задачи могут достаточно долго находиться в очереди. Задача просто попадает в календарь спустя несколько таких планировок запросов. Было решено оставить это как часть изначальной архитектуры. Исходный процессор ведь не меняли и добавили точно такой же.

Время обработки процесса из очереди считается от его попадания в календарь.
Как только процессор завершает задание, он пишет одно из очереди в календарь и то задание пропадает из очереди.
